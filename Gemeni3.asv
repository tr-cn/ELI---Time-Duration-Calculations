% ULTRAFAST_FFT.M
%
% This script calculates the Transform-Limited (TL) Pulse Duration (FWHM)
% from a measured spectral intensity (I(lambda)).
%
% The calculation correctly accounts for the non-linear relationship between 
% wavelength and frequency by resampling the spectrum onto a uniform 
% frequency grid before applying the Inverse Fourier Transform.

% --- Physical Constants ---
% C_LIGHT definition is moved into the function below for correct scoping
% in MATLAB when using local functions.

% ====================================================================
% --- MAIN EXECUTION BLOCK ---
% ====================================================================
load ('OAP_Zoome_dara_data.mat');
lambda = wavelengths_nm;
I = abs(y_pixels - max(y_pixels));
calculate_transform_limit_matlab(lambda, I);

function [tau_tl_fs, tbp] = calculate_transform_limit_matlab(wavelengths_nm, intensity)
    % Calculates the Transform-Limited (TL) Pulse Duration (FWHM) from I(lambda).
    
    % Define constants locally for function scope access
    C_LIGHT = 299792458.0; % Speed of light in m/s

    avg_lambda = mean(wavelengths_nm);
    fprintf('\n--- Processing Spectrum (Center: %.2f nm) ---\n', avg_lambda);

    % 1. Convert Wavelength (nm) to Frequency (THz)
    wavelengths_m = wavelengths_nm * 1e-9;
    frequencies_hz = C_LIGHT ./ wavelengths_m;
    frequencies_thz = frequencies_hz * 1e-12;

    % The spectral amplitude E(nu) is proportional to: E(nu) ~ sqrt(I(lambda)) * |dlambda/dnu|
    % Since |dlambda/dnu| ~ lambda^2 / c, we use the lambda^2 factor.
    spectral_amplitude_nu = sqrt(intensity) .* (wavelengths_m.^2);

    % 2. Resampling onto a uniform frequency grid (Interpolation)
    % Interpolation requires the X-axis (frequencies) to be sorted (ascending).
    [frequencies_sorted, sort_idx] = sort(frequencies_thz);
    amplitude_sorted = spectral_amplitude_nu(sort_idx);

    freq_min = frequencies_sorted(1);
    freq_max = frequencies_sorted(end);
    
    % --- CONTROL POINT 1: INTERPOLATION DENSITY ---
    % Use a large number of points for the interpolation grid (power of 2 is recommended)
    num_interp_points = 2^12; % e.g., 4096 points
    
    % --- CONTROL POINT 2: FFT SIZE / ZERO PADDING ---
    % This defines the size of the array used for the IFFT and sets the time resolution.
    num_fft_points = 2^14; % e.g., 16384 points (must be >= num_interp_points)

    % Create the uniform grid in THz for interpolation
    uniform_freq_thz = linspace(freq_min, freq_max, num_interp_points);
    
    % Interpolate the spectral amplitude onto the uniform grid
    % 'linear' interpolation, 'extrap' for extrapolation with zero padding
    uniform_amplitude = interp1(frequencies_sorted, amplitude_sorted, ...
                                uniform_freq_thz, 'linear', 0);

    % 3. Inverse Fourier Transform (IFFT) with Centered Zero Padding
    % For TL pulse, the spectral phase is assumed to be zero.
    
    % 1. Determine padding size
    padding_needed = num_fft_points - num_interp_points;
    if padding_needed < 0
        error('FFT size (num_fft_points) must be greater than or equal to interpolation size (num_interp_points).');
    end
    
    % 2. Calculate symmetric padding for front and back
    pad_before = floor(padding_needed / 2);
    pad_after = ceil(padding_needed / 2);

    % 3. Apply Zero Padding to the Interpolated Amplitude
    % Concatenate zeros to pad the interpolated array
    padded_amplitude = [zeros(1, pad_before), uniform_amplitude, zeros(1, pad_after)];

    % IFFT shift moves the DC component (center frequency) to the start for standard IFFT
    fft_input = ifftshift(padded_amplitude);
    
    % Calculate the IFFT. This gives the electric field in the time domain, E(t)
    temporal_field = ifft(fft_input);
    
    % *** FIX: Calculate Intensity from Field ***
    temporal_intensity = abs(temporal_field).^2;
    % *******************************************
    
    % 4. Determine Time Axis and FWHM
    
    % Frequency step (Hz) - defined by the interpolation grid
    delta_nu_thz = uniform_freq_thz(2) - uniform_freq_thz(1);
    delta_nu_hz = delta_nu_thz * 1e12; % Frequency resolution in Hz
    
    % Total time range is 1/delta_nu_hz
    total_time = 1.0 / delta_nu_hz; 
    
    % Time step (seconds) - defined by the FFT size
    time_step = total_time / num_fft_points;
    
    % Correct time axis calculation for centered FFT
    % Time axis runs from -T/2 to T/2 (excluding the positive edge point)
    time_array = time_step * ((-num_fft_points/2) : (num_fft_points/2 - 1));

    % Shift the intensity profile back to be centered
    % The IFFT result must be shifted to center the pulse at t=0
    temporal_intensity_shifted = fftshift(temporal_intensity);

    % Find FWHM in seconds and convert to femtoseconds
    tau_tl_seconds = find_fwhm_matlab(time_array, temporal_intensity_shifted);
    tau_tl_fs = tau_tl_seconds * 1e15; % Convert TL duration from seconds to femtoseconds
    
    % Calculate TBP (Time-Bandwidth Product)
    delta_lambda_fwhm = find_fwhm_matlab(wavelengths_nm, intensity); % FWHM of the input spectrum (nm)
    
    % Calculate the frequency bandwidth (FWHM) corresponding to delta_lambda_fwhm
    % d_nu = c/lambda^2 * d_lambda
    avg_lambda_m = avg_lambda * 1e-9;
    
    % Convert the lambda FWHM (nm) to the corresponding frequency FWHM (THz)
    delta_nu_fwhm_thz = C_LIGHT / (avg_lambda_m^2) * (delta_lambda_fwhm * 1e-9) * 1e-12; 
    
    % TBP = tau_TL (s) * Delta_nu (Hz)
    tbp = (tau_tl_fs * 1e-15) * (delta_nu_fwhm_thz * 1e12);
    
    % --- Display Results ---
    if ~isempty(tau_tl_fs)
        fprintf('  > Input FWHM (nm): %.2f nm\n', delta_lambda_fwhm);
        fprintf('  > Transform-Limited Duration (Ï„_TL): %.2f fs\n', tau_tl_fs);
        fprintf('  > Time-Bandwidth Product (TBP): %.3f\n', tbp);
    else
        fprintf('  > Error: Could not reliably determine FWHM for this spectrum.\n');
    end
end


% ====================================================================
% --- HELPER FUNCTION: FWHM FINDER ---
% ====================================================================

function fwhm_out = find_fwhm_matlab(x_array, intensity_array)
    % Calculates the Full Width at Half Maximum (FWHM) of the pulse/spectrum.
    % Returns the FWHM in the same units as x_array.
    
    % Ensure data is column vector for consistent indexing
    x = x_array(:);
    I = intensity_array(:);

    % Normalize and find half maximum
    I_norm = I / max(I);
    half_max = 0.5;
    
    % Find indices where intensity is above half maximum
    indices_above_half = find(I_norm >= half_max);

    if isempty(indices_above_half)
        fwhm_out = [];
        return; 
    end

    % Find the edges of the FWHM region
    start_idx = indices_above_half(1);
    end_idx = indices_above_half(end);

    % --- Interpolation for the Left Edge (Lower X) ---
    % Look at points around the start index. Ensure the first point is below half_max.
    if start_idx > 1
        x_left = x(start_idx-1 : start_idx);
        I_left = I_norm(start_idx-1 : start_idx);
        % Interpolate to find the exact x-value where I_norm is 0.5
        t1 = interp1(I_left, x_left, half_max, 'linear');
    else
        % Edge case: FWHM starts at the array boundary
        t1 = x(start_idx); 
    end

    % --- Interpolation for the Right Edge (Higher X) ---
    % Look at points around the end index. Ensure the last point is below half_max.
    if end_idx < length(I_norm)
        x_right = x(end_idx : end_idx+1);
        I_right = I_norm(end_idx : end_idx+1);
        % Interpolate to find the exact x-value where I_norm is 0.5
        t2 = interp1(I_right, x_right, half_max, 'linear');
    else
        % Edge case: FWHM ends at the array boundary
        t2 = x(end_idx);
    end

    % Calculate FWHM
    fwhm_out = abs(t2 - t1);
    
end